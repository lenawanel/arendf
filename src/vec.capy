core :: mod "core";
util :: import "util.capy";


Vec :: struct {
    buf: [] u8,
    cap: usize
};

new :: () -> Vec {
    cap   :: 0x100;
    alloc :: core.libc.malloc(cap) as ^u8;
    Vec {
        buf: util.construct_u8slice(alloc, 0),
        cap: cap
    }
}

append :: (vec: ^mut Vec, to_append: [] u8) {
    while { vec.buf.len + to_append.len > vec.cap } {
        grow(vec);
    }
    idx := 0;
    while idx < to_append.len {
        vec.buf.len = vec.buf.len + 1;
        vec.buf[vec.buf.len - 1] = to_append[idx];
        idx = idx + 1;
    }
}

grow :: (vec: ^mut Vec) {
    vec.buf.ptr = util.realloc(vec.buf.ptr as ^any, vec.cap * 8) as ^u8;
    vec.cap = vec.cap * 8;
}

dealloc :: (vec: Vec) {
    core.libc.free(vec.buf.ptr);
}

as_slice :: (vec: ^Vec) -> [] u8 {
    vec.buf
}